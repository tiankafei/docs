# spring cloud

## eureka自我保护机制

### 自我保护背景

首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。

默认情况下，**如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。**但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。

### 自我保护机制

官方对于自我保护机制的定义：

```
自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。
```

自我保护机制的工作机制是：**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**，此时会出现以下几种情况：

1. Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用
3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中

因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。

### 自我保护开关

Eureka自我保护机制，通过配置 `eureka.server.enable-self-preservation` 来`true`打开/`false`禁用自我保护机制，默认打开状态，建议生产环境打开此配置。

### 开发环境配置

开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。

1. 注册中心关闭自我保护机制，修改检查失效服务的时间

   ```yaml
   eureka:
     server:
        enable-self-preservation: false
        eviction-interval-timer-in-ms: 3000
   ```

2. 微服务修改减短服务心跳的时间

   ```yaml
   eureka:
     instance:
       # 默认90秒
       lease-expiration-duration-in-seconds: 90
       # 默认30秒
       lease-renewal-interval-in-seconds: 30
   ```

## @Autowired注解与@Resource注解的区别

### 相同点

@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。

### 不同点

1. 提供方：@Autowired是由Spring提供；@Resource是由J2EE提供，需要JDK1.6及以上
2. 注入方式：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；
3. 属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。

### @Resource装配顺序

1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常
2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；

推荐使用@Resource注解在字段上，这样就不用写setter方法了.并且这个注解是属于J2EE的，减少了与Spring的耦合,这样代码看起就比较优雅 。

## 秒杀的分布式锁场景

### 前提

已有的系统功能完善，稳定。

### 特点

稳定，短时间，高并发

### 目标

不多卖，不少卖，服务的可用性，服务器响应速度快

### 实现流程

![秒杀流程图](\images\秒杀流程图.png)

### 如何提高加锁阻塞的效率？

- 库存分段，10个10个的锁，并发效率提高了10倍

### 秒杀场景优化思路

1. 请求的数据量要少（接口数据少）
2. 请求的路径要端（减少链路调用次数）
3. 相关依赖要少
4. 不要单点
5. CDN分发
6. 动静分离（静态数据做缓存，减少服务器压力）
7. 识别热点数据，为系统扩容做准备（当前置的耗费资源少的接口被频繁调用时，说明热点数据快要来了）
8. 使用消息队列进行削峰，前面简单处理一下，就扔到MQ里，后面进行排队，慢慢的去进行消费
9. 答题，输验证码
10. 网络（网络请求转发）、CPU（优化程序的并发）、内存（自己的内存+Redis）、硬盘（MySQL）

## Object类的方法说明

### toString() 方法

返回对象的描述信息：全类名@哈希码值的十六进制形式

```
编程规范：开发者要对自定义的类重写toString()，对对象做详细的说明
```

### hashCode() 方法

返回该对象的哈希码值，int类型；
同一个对象的哈希码值是唯一的。java规定如果两个对象equals返回true，那么这两个对象的hashCode码必须一致。

```
编程规范： 一般重写了类的equals方法后，都会重写它的hashCode方法
```

### toString和hashCode哈希码的联系

```
他们之间是十六进制与十进制之间的关系！
```

### equals() 方法

默认比较的是两个对象的内存值，相等返回 true，否则 false。可重写equals方法。

问题：既然equals比较的是对象的内存值，那我们在开发的时候经常使用 equals() 方法比较两个字符串是否相等，为什么？

```
String 重写了Object类的equals方法，比较的是字符串内容是否相等。
```

### equals 和 ==

#### **==**

- 比较基本数据类型，比较的是值是否相等。
- 比较引用数据类型，比较的是地址是否相等。

#### **equals**

- 比较的是两个对象的地址值是否相等，此时等价 ==。
- 重写后按照重写后的方式比较。

### equals 和 hashCode 方法

#### 作用

都是用于比较java对象是否一致

- equals：重写的equal() 方法里一般比较全面、复杂，效率低。
- hashCode：生成一个int类型的hash值。效率高，但hash值可能不唯一。

#### 问题

由于hash值的生成问题，可能导致不同的对象，hash值相同。

#### 结论

- equal()对比绝对可靠（equal()相等的两个对象他们的hashCode()肯定相等）
- hashCode()不是绝对可靠的（hashCode()相等的两个对象他们的equal()不一定相等）

#### 使用

​		所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

## String的hashcde算法

### hashcde源码

```java
/** The value is used for character storage. */  
private final char value[];  //将字符串截成的字符数组  

/** Cache the hash code for the string */  
private int hash; // Default to 0 用以缓存计算出的hashcode值  

/** 
* Returns a hash code for this string. The hash code for a 
* <code>String</code> object is computed as 
* <blockquote><pre> 
* s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 
* </pre></blockquote> 
* using <code>int</code> arithmetic, where <code>s[i]</code> is the 
* <i>i</i>th character of the string, <code>n</code> is the length of 
* the string, and <code>^</code> indicates exponentiation. 
* (The hash value of the empty string is zero.) 
* 
* @return  a hash code value for this object. 
*/  
public int hashCode() {  
	int h = hash;  
	if (h == 0 && value.length > 0) {  
		char val[] = value;  

		for (int i = 0; i < value.length; i++) {  
			h = 31 * h + val[i];  
		}  
		hash = h;  
	}  
	return h;  
}
```

### 举例说明

```
String msg = "abcd";  // 此时value[] = {'a','b','c','d'}  因此

for循环会执行4次
第一次：h = 31*0 + a = 97
第二次：h = 31*97 + b = 3105
第三次：h = 31*3105 + c = 96354
第四次：h = 31*96354 + d = 2987074
由以上代码计算可以算出 msg 的hashcode = 2987074  刚好与 System.err.println(new String("abcd").hashCode()); 进行验证
 
在源码的hashcode的注释中还提供了一个多项式计算方式：
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]      
s[0] ：表示字符串中指定下标的字符
n：表示字符串中字符长度
a*31^3 + b*31^2 + c*31^1 + d = 2987074  + 94178 + 3069 + 100 = 2987074 ;
```

## MQ100%投递及消费

### 核心点

1. 消息收到先落地
2. 消息超时、重传、确认保证消息必达

### MQ投递消息

1. 客户端给MQ服务器发送消息
2. MQ服务器将消息落地，落地后即为发送成功
3. MQ服务器将应答发送给MQ客户端

说明：MQ投递消息的1或者2或者3如果丢失或者超时，MQ客户端内的定时器会重发消息，直到期望收到3，如果重传N次后还未收到，则回调发送失败（说明此时网络可能存在问题了；如果要求100%投递成功，可以先把失败的消息存储到一个第三方介质上，过段时间网络恢复了再进行消息投递）需要注意的是，这个过程中MQ服务器可能会收到同一条消息的多次重发

### MQ消费消息

1. MQ服务器将消息发送给MQ客户端
2. MQ客户端回复MQ服务器接受完成
3. MQ服务器收到ACK应答，将已经落地的消息删除，完成消息的可靠传递

说明：MQ消费消息的1或者2或者3如果丢失或者超时，MQ服务器内的定时器会重发消息，直到收到2并且成功执行3，这个过程可能会重发很多次消息，一般采用指数退避的策略，先隔x秒重发，2x秒重发，4x秒重发，以此类推，需要注意的是，这个过程中MQ客户端也可能会收到同一条消息的多次重发

```
MQ投递消息与MQ消费消息如何进行消息去重，需要进行MQ架构幂等性设计！！！
```

## 幂等的设计思路

### MQ幂等设计

#### MQ投递消息的幂等设计

此时重发的是MQ客户端，消息处理的是MQ服务器端，为了避免步骤2落地重复的消息，对每条消息，MQ系统内部必须生成一个内部的消息id（inner-msg-id），作为去重和幂等的依据，这个内部消息ID的特性是：

1. 全局唯一
2. MQ生成，具备业务无关性，对消息发送发和消息接收方屏蔽

```
有了这个inner-msg-id，就能保证MQ投递消息的重发，只有1条消息落到MQ服务器中，实现MQ消息投递的幂等。
```

#### MQ消费消息的幂等设计

此时重发的是MQ服务器，消息的处理是消息消费业务方，消息重发势必会导致业务方重复消费，为了保证业务幂等性，业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务id的特性是：

1. 对于同一个业务场景，全局唯一
2. 由业务消息发送方生成，业务相关，对MQ透明
3. 由业务消息消费方负责判重，以保证幂等

```
最常见的业务id有：支付id，订单id，帖子id等；有了这个业务id，才能够保证MQ消息消费业务方即使收到重复的消息，也只有1条被消费，保证了幂等。
```

#### MQ幂等设计总结

- MQ投递消息
  - MQ客户端内部或者MQ服务器生成inner-msg-id，保证MQ投递消息幂等
  - 这个id全局唯一，业务无关，由MQ保证
- MQ消费消息
  - 业务发送发带入biz-id，业务接收方去重保证幂等
  - 这个id对业务唯一，业务相关，对MQ透明

```
结论：幂等性，不仅对MQ有要求，对业务上下游也有要求。
```

### 服务接口幂等设计

#### 保证接口幂等性的要求

1. 对于每个请求必须有一个唯一的标识
2. 每次处理完请求之后，必须有一个记录标识这个请求处理过了
3. 每次接收请求需要进行判断之前是否处理过的逻辑处理

### 用户重复提交问题,Nginx重试,Ribbon重试

这个问题等同于表单重复提交，一般的解决思路是token机制。

```
也就是说在表单提交之前需要向后端申请token，后端返给前端token的同时需要把token保存到redis中，并设置超时时间。请求接口时，将此token放在header中或者作为参数，后端判断token是否存在，存在则删除token并正常处理业务逻辑；否则返回重复提交提示。
```

## 分布式锁

### 分布式锁的特点

1. 互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁
2. 安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除
3. 防死锁：获取锁的客户端因为某些原因（如down机等），需要设置一个策略把锁释放掉，否则其他客户端再也无法获取到该锁
4. 容错性：当部分服务节点down机时，客户端仍然能够获取锁和释放锁

### 基于数据库的锁

利用数据库的行级锁实现

### 基于Zookeeper的分布式锁

利用zk临时顺序节点的特性来实现

### 基于Redis单机的锁

使用redis set nx命令来实现

### 基于Redisson分布式锁

多个redis实例之间毫无任何关系，加锁成功的个数超过半数+1，即获得锁成功

## 分布式事务



## feign调用全过程