# spring cloud

## eureka自我保护机制

### 自我保护背景

首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。

默认情况下，**如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。**但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。

### 自我保护机制

官方对于自我保护机制的定义：

```
自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。
```

自我保护机制的工作机制是：**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**，此时会出现以下几种情况：

1. Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用
3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中

因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。

### 自我保护开关

Eureka自我保护机制，通过配置 `eureka.server.enable-self-preservation` 来`true`打开/`false`禁用自我保护机制，默认打开状态，建议生产环境打开此配置。

### 开发环境配置

开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。

1. 注册中心关闭自我保护机制，修改检查失效服务的时间

   ```yaml
   eureka:
     server:
        enable-self-preservation: false
        eviction-interval-timer-in-ms: 3000
   ```

2. 微服务修改减短服务心跳的时间

   ```yaml
   eureka:
     instance:
       # 默认90秒
       lease-expiration-duration-in-seconds: 90
       # 默认30秒
       lease-renewal-interval-in-seconds: 30
   ```

## @Autowired注解与@Resource注解的区别

### 相同点

@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。

### 不同点

1. 提供方：@Autowired是由Spring提供；@Resource是由J2EE提供，需要JDK1.6及以上
2. 注入方式：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；
3. 属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。

### @Resource装配顺序

1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常
2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；

推荐使用@Resource注解在字段上，这样就不用写setter方法了.并且这个注解是属于J2EE的，减少了与Spring的耦合,这样代码看起就比较优雅 。

## 秒杀的分布式锁场景

### 前提

已有的系统功能完善，稳定。

### 特点

稳定，短时间，高并发

### 目标

不多卖，不少卖，服务的可用性，服务器响应速度快

### 实现流程

![秒杀流程图](\images\秒杀流程图.png)

### 如何提高加锁阻塞的效率？

- 库存分段，10个10个的锁，并发效率提高了10倍

### 秒杀场景优化思路

1. 请求的数据量要少（接口数据少）
2. 请求的路径要端（减少链路调用次数）
3. 相关依赖要少
4. 不要单点
5. CDN分发
6. 动静分离（静态数据做缓存，减少服务器压力）
7. 识别热点数据，为系统扩容做准备（当前置的耗费资源少的接口被频繁调用时，说明热点数据快要来了）
8. 使用消息队列进行削峰，前面简单处理一下，就扔到MQ里，后面进行排队，慢慢的去进行消费
9. 答题，输验证码
10. 网络（网络请求转发）、CPU（优化程序的并发）、内存（自己的内存+Redis）、硬盘（MySQL）

## MQ100%投递及消费



## 幂等的设计思路



## feign调用全过程

