# zookeeper学习笔记

## 1. zookeeper概念

zookeeper是用于分布式应用程序的分布式，开放源代码协调服务。它公开了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名的更高级别的服务。它的设计易于编程，并使用了按照文件系统熟悉的目录树结构命名的数据模型。众所周知，协调服务很难做到。它们特别容易出现诸如比赛条件和死锁之类的错误。zookeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。

## 2. 设计目标

zookeeper很简单。zookeeper允许分布式进程通过共享的分层名称空间相互协调，该命名空间的组织方式类似于标准文件系统。名称空间由数据寄存器（在zookeeper看来，称为znode）组成，它们类似于文件和目录。与设计用于存储的典型文件系统不同，zookeeper数据保留在内存中，这意味着zookeeper可以实现高吞吐量和低延迟数。

![zookeeper-service](/images/zookeeper-service.jpg)

## 3. 数据模型和分层名称空间

zookeeper提供的名称空间与标准文件系统的名称空间非常相似。名称是由斜杠（/）分隔的一系列路径元素。zookeeper命名空间中的每个节点都由路径标识。

![zookeeper-namespace](/images/zookeeper-namespace.jpg)



## 4. 特点

zookeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。这些是：

- 顺序一致性-来自客户端的更新将按照发送的顺序应用。
- 原子性-更新成功或失败。没有部分结果。
- 单个系统映像-无论客户端连接到哪个服务器，客户端都将看到相同的服务视图。也就是说，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。
- 可靠性-一旦应用了更新，该更新将一直持续到客户端覆盖更新为止。
- 及时性-确保系统的客户视图在特定时间范围内是最新的。

## 5. 简单的API

zookeeper的设计目标之一是提供一个非常简单的编程界面。因此，它仅支持以下操作：

- *create*：在树中的某个位置创建一个节点
- *delete*：删除节点
- *存在*：测试某个位置是否存在节点
- *获取数据*：从节点读取数据
- *设置数据*：将数据写入节点
- *获取子*节点：获取节点子节点的列表
- *sync*：等待数据传播

## 6. 角色

### 6.1 Leader 

1. 一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer
   及 Observer 间的心跳
2. 所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。 只要有超过
   半数节点（不包括 observeer 节点） 写入成功，该写请求就会被提交（类 2PC 协议）

### 6.2 Follower 

1. 一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳
2. Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理
3. 并且负责在 Leader 处理写请求时对请求进行投票

### 6.3 Observer  

角色与 Follower 类似，但是无投票权。 Zookeeper 需保证高可用和强一致性，为了支持更多的客
户端，需要增加更多 Server； Server 增多，投票阶段延迟增大，影响性能； 引入 Observer，
Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点； 加入更
多 Observer 节点，提高伸缩性，同时不影响吞吐率。  

## 7. 选举策略

- 首先查看数据完整性（使用事务ID）
- 在达到数据完整性的前提下，查看myid的配置，谁大谁就是leader

